Like Lock, Monitor, Mutex, and Semaphore, the SemaphoreSlim class in C# is also used to provide thread safety. 
The Lock and Monitors are basically used to provide thread safety for Internal Threads 
i.e. the threads generated by the application itself. 
On the other hand, Mutex and Semaphore ensure thread safety for threads that are generated by the external applications 
i.e. External Threads. 
Using Mutex, only one external thread can access our application code at any given point in time. 
And, if we want more control over the number of external threads that can access our application code, then can use Semaphore in C#.

Using Lock and Monitor, 
only one internal thread can access our application code at any given point in time. 
But, if we want more control over the number of internal threads that can access our application code, 
then we need to use SemaphoreSlim class in C#.

//SemaphoreSlim:

When we instantiate a SemaphoreSlim, 
we can specify the maximum number of threads that can enter the critical section concurrently. 
We also specify the initial number of threads that can enter the critical section concurrently. 
This defines the semaphore’s count. 
The count is decremented each time a thread enters the SemaphoreSlim and incremented each time a thread releases the SemaphoreSlim.

To enter the SemaphoreSlim, a thread has to call one of the Wait or WaitAsync overload methods. 
To release the SemaphoreSlim, the thread has to call one of the Release methods. When the count reaches zero, 
subsequent calls to the Wait method block until other threads release the SemaphoreSlim. 
If multiple threads are blocked, there is no guaranteed order, such as FIFO or LIFO, that controls when threads enter the semaphore.

Note:
We use SemaphoreSlim instance to limit the concurrent threads that can access a shared resource in a multi-threaded environment. 
If threads trying to access a resource are more than the declared limit, 
only limited threads will be granted access and others will have to wait.